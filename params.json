{"name":"TimeData.jl","tagline":"TimeData package for Julia language","body":"<div id=\"table-of-contents\">\r\n<h2>Table of Contents</h2>\r\n<div id=\"text-table-of-contents\">\r\n<ul>\r\n<li><a href=\"#sec-1\">1. TimeData types</a></li>\r\n<li><a href=\"#sec-2\">2. Constructors</a></li>\r\n<li><a href=\"#sec-3\">3. Indexing</a></li>\r\n<li><a href=\"#sec-4\">4. Read, write, io</a></li>\r\n<li><a href=\"#sec-5\">5. Functions and operators inherited from DataFrames</a></li>\r\n<li><a href=\"#sec-6\">6. Additional functions</a></li>\r\n<li><a href=\"#sec-7\">7. Acknowledgement</a></li>\r\n</ul>\r\n</div>\r\n</div>\r\n\r\n# TimeData types\r\n\r\nAll types introduced are subtypes of abstract type `AbstractTimedata`\r\nand have two fields, separating time information from observations:\r\n\r\n- **vals:** a `DataFrame`\r\n- **idx:** an `Array{T, 1}`, consisting of type `Integer`, or type\r\n             `Date` or `DateTime` from package `Datetime`\r\n\r\n\r\nHowever, accessing these fields directly is considered poor style, as\r\none could circumvent any constraints on the individual fields this\r\nway! Hence, only reference the fields directly if you really know what\r\nyou are doing.\r\n\r\nGiven these commonalities of all `TimeData` types, there exist several\r\ndistinct types that implement different constraints on the\r\nobservations. Sorted from most general to most specific case, the\r\nfollowing types are introduced:\r\n\r\n- **`Timedata`:** no further restrictions on observations\r\n\r\n- **`Timenum`:** observations may consist of numeric values or missing\r\n    values only\r\n\r\n-   **`Timematr`:** observations must be numeric values only\r\n\r\n-   **`Timecop`:** observations must be numeric values between 0 and 1\r\n    only\r\n\r\nGiven that these constraints are fulfilled, one is able to define and\r\nuse more specific functions matching the data characteristics more\r\nclosely. For example, `Timematr` instances can directly make use of\r\nfast and numerically optimized methods using `Array{Float64, 2}` under\r\nthe hood. Hence, it is important that these constraints are reliably\r\nfulfilled. They are guaranteed as they are hard-coded into variables\r\nat creation through the individual constructors. And, by now, no\r\nfurther `setindex` methods exist that would allow data manipulation.\r\n\r\n# Constructors\r\n\r\nFor each type, variables can be created by directly handing over\r\nobservations as `DataFrame` and time information as `Array` to the\r\ninner constructor.\r\n\r\n    using TimeData\r\n    using Datetime\r\n\r\n    vals = rand(30, 4)\r\n    dats = Date{ISOCalendar}[date(2013, 7, ii) for ii=1:30]\r\n    nams = [\"A\", \"B\", \"C\", \"D\"]\r\n    valsDf = DataFrame(vals, nams)\r\n    \r\n    tm = Timematr(valsDf, dats)\r\n\r\nBesides, there also exist several outer constructors for each type,\r\nallowing more convenient creation. In particular, if observations do\r\nnot entail any `NAs`, there is no need to wrap them up into\r\n`DataFrames` previously, but `TimeData` objects can simply be created\r\nfrom `Arrays`. Also, there might be situations where variable names\r\nand / or dates are missing. For these cases, there exist more\r\nconvenient outer constructors, too, which generally follow the\r\nconvention that dates do never precede variable names as arguments.\r\n\r\n    tm = Timematr(vals, nams, dats)\r\n    tm = Timematr(vals, nams)\r\n    tm = Timematr(vals, dats)\r\n    tm = Timematr(vals)\r\n\r\n# Indexing\r\n\r\nThe idea of `getindex` is to stick with the behavior of `DataFrames`\r\nas far as possible for the basics, while extending it to allow\r\nindexing of rows by dates. Hence, indexing `TimeData` types should\r\nhopefully fit seamlessly into behavior familiar from other important\r\ntypes, with only intuitive extensions. However, it is important to\r\nnote that indexing deviates from `DataFrame` behavior in one aspect:\r\n`getindex` will NEVER change the type of the variable! If you call it\r\non a `Timematr` variable, it will also return a `Timematr` variable,\r\nand if you call it on type `Timenum` it will return `Timenum` as well.\r\nAlthough this seems to be quite logically, this behavior does deviate\r\nfrom `DataFrame` behavior in such that, for example, `DataFrames`\r\nreturn `DataArray` for single columns.\r\n\r\n    typeof(valsDf[:, 1])\r\n    typeof(tm[:, 1])\r\n    \r\n    typeof(valsDf[1, 1])\r\n    typeof(tm[1, 1])\r\n    \r\n    ## empty instance\r\n    typeof(tm[4:3, 5:4])\r\n\r\nThis will print:\r\n\r\n    DataArray{Float64,1} (constructor with 1 method)\r\n    Timematr{Date{ISOCalendar}} (constructor with 1 method)\r\n    \r\n    Float64\r\n    Timematr{Date{ISOCalendar}} (constructor with 1 method)\r\n    \r\n    \r\n    Timematr{Date{ISOCalendar}} (constructor with 1 method)\r\n\r\n\r\nPossible ways of indexing are:\r\n\r\n    ## indexing by numeric indices\r\n    tmp = tm[2:4]\r\n    tmp = tm[3:5, 1:2]\r\n    tmp = tm[5, :]\r\n    tmp = tm[2]\r\n    tmp = tm[5:8, 2]\r\n    tmp = tm[5, 3]\r\n    \r\n    ## indexing with column names as symbols\r\n    tmp = tm[:A]\r\n    tmp = tm[5, [:A, :B]]\r\n    \r\n    ## logical indexing\r\n    logicCol = [true, false, true, false]\r\n    logicRow = repmat([true, false, true], 10, 1)[:]\r\n    tmp = tm[logicCol]\r\n    tmp = tm[logicRow, logicCol]\r\n    tmp = tm[logicRow, :]\r\n    \r\n    ## logically indexing rows directly from expression\r\n    ex = :(A .> 0.5)\r\n    tmp = tm[ex, :]\r\n    \r\n    ## indexing by date\r\n    tmp = tm[date(2013, 07, 04)]\r\n    \r\n    datesToFind = Date{ISOCalendar}[date(2013, 07, ii) for ii=12:18]\r\n    tmp = tm[datesToFind]\r\n    tm[date(2013,07,03):date(2013,07,12)]\r\n    tm[date(2013,07,03):date(2013,07,12), :D]\r\n    tm[date(2013,07,03):date(2013,07,12),\r\n                 [true, false, false, true]]\r\n\r\n# Read, write, io\r\n\r\nData can easily be imported from csv-files using function\r\n`readTimedata`. Under the hood, the function makes use of `readtable`\r\nfrom the `DataFrames` package. Additionally, columns are parsed for\r\ndates similar to function `readtime` from package `TimeSeries`. The\r\nfirst column matching the regexp for dates will be chosen as time\r\nidentifier. \r\n\r\n    tm = readTimedata(\"data/logRet.csv\")\r\n\r\nAfter loading the data, Julia will call the standard `display` method\r\nto show information about the data:\r\n\r\n    \r\n    type: Timematr{Date{ISOCalendar}}\r\n    dimensions: (333,348)\r\n    333x6 DataFrame:\r\n                   dates      MMM      ABT      ACE      ACT     ADBE\r\n    [1,]      2012-01-03  2.12505  0.88718  0.29744  0.47946   1.0556\r\n    [2,]      2012-01-04  0.82264 -0.38476 -0.95495 -0.52919 -1.02024\r\n    [3,]      2012-01-05 -0.44787 -0.23157  0.28445  2.74752  0.70472\r\n    [4,]      2012-01-06 -0.51253 -0.93168  0.23891  1.94894  0.83917\r\n    [5,]      2012-01-09  0.58732      0.0  0.46128  0.28436 -0.66376\r\n    [6,]      2012-01-10  0.52193  0.46693  1.31261  1.85986  2.32125\r\n    [7,]      2012-01-11 -0.63413 -0.38895 -1.52066 -3.06604  0.41012\r\n    [8,]      2012-01-12  0.60934 -0.46875  0.50453 -0.93039 -0.30743\r\n    [9,]      2012-01-13 -0.80912  0.50771 -0.47478  0.25752 -0.89348\r\n    [10,]     2012-01-17  0.74711  0.50515    0.297 -7.04176  1.30317\r\n    [11,]     2012-01-18  0.98754  -0.6611  0.17778 -0.06901  1.82314\r\n    [12,]     2012-01-19  0.85617  0.15595   1.1918  3.92605  1.16416\r\n    [13,]     2012-01-20 -0.17065  0.58264  2.42751 -3.58146  0.85611\r\n    [14,]     2012-01-23 -0.04881 -0.07749 -1.20639 -1.61252 -0.88919\r\n    [15,]     2012-01-24  0.37766  0.46404 -0.98738 -2.33432  2.35382\r\n    [16,]     2012-01-25  0.63031 -1.35951  0.81384  3.03107  1.25222\r\n    [17,]     2012-01-26  1.26075  -0.6277  -0.5952  1.78914 -0.51184\r\n    [18,]     2012-01-27 -0.13134   0.2751  -2.5512  1.84142 -0.41781\r\n    [19,]     2012-01-30 -0.14347 -1.02565 -0.68945  0.26747 -0.16116\r\n    [20,]     2012-01-31 -0.72046 -0.59654  0.89834   -2.143 -0.16142\r\n      :\r\n    [314,]    2013-04-04  0.13388  0.88398  1.18103  0.59652  1.16029\r\n    [315,]    2013-04-05 -0.03823 -0.91173 -0.09035  1.39877 -1.89525\r\n    [316,]    2013-04-08 -0.02868   0.6639  1.19062  1.19664   0.9407\r\n    [317,]    2013-04-09  0.19108  0.27533  0.54563 -0.66303  0.86403\r\n    [318,]    2013-04-10  1.62836  1.20253  0.44321 -0.51303  1.19277\r\n    [319,]    2013-04-11  0.51515  0.83864  1.06671  0.56419  1.13448\r\n    [320,]    2013-04-12 -0.52454 -0.37787  0.08747 -0.44082 -0.39894\r\n    [321,]    2013-04-15 -1.80048  -2.7414 -3.52592 -1.34466 -0.95951\r\n    [322,]    2013-04-16  0.37223  0.74762   1.1929   0.9741  1.51316\r\n    [323,]    2013-04-17 -0.63074  2.39859 -1.07975  0.78069 -0.84276\r\n    [324,]    2013-04-18 -0.48049 -1.08314 -0.63528  -1.0802 -0.98479\r\n    [325,]    2013-04-19  0.69118  0.86745  0.77089  1.84469   0.6278\r\n    [326,]    2013-04-22  0.08606 -0.84023  0.27067 -0.64178 -0.47048\r\n    [327,]    2013-04-23  1.48952  0.86721   0.8188  0.93582  0.76063\r\n    [328,]    2013-04-24    0.451  -1.8794 -0.51518 -0.49734 -0.44673\r\n    [329,]    2013-04-25 -2.81414 -0.08252 -0.04492  0.61876  0.84708\r\n    [330,]    2013-04-26 -1.04683 -0.08259 -0.63106  2.05182 -0.31125\r\n    [331,]    2013-04-29  0.03897  0.74085 -0.02261  4.49427  0.33344\r\n    [332,]    2013-04-30  0.84381  0.51807  0.24845  0.14197  0.04438\r\n    [333,]    2013-05-01 -0.14498 -0.08162 -0.94057 -1.27548 -0.82415\r\n\r\nAs one can see, the `display` method will show the type of the\r\nvariable, together with its dimensions and a snippet into the first\r\nvalues. Note that the number of columns does not entail the dates\r\ncolumn, but does only count the columns of the remaining variables.\r\nInherently, `display` makes use of the method that is implemented for\r\n`DataFrames`, which is the reason for the somewhat misleading output\r\nline `333x6 DataFrame:`. An issue that still remains to be fixed. In\r\ncontrast to the standard output of `DataFrames`, there is no explicit\r\ninformation for the rest of the columns. \r\n\r\nAn even more elaborate way of looking at the data contained in a\r\n`TimeData` type is function `str` (following the name used in R),\r\nwhich will print:\r\n\r\n    str(tm)\r\n\r\n    \r\n    type: Timematr{Date{ISOCalendar}}\r\n    :vals         DataFrame\r\n    :idx          Array{Date{ISOCalendar},1}\r\n    \r\n    dimensions: (333,348)\r\n    \r\n    -------------------------------------------\r\n    From: 2012-01-03, To: 2013-05-01\r\n    -------------------------------------------\r\n    \r\n    333x6 DataFrame:\r\n                   dates      MMM      ABT      ACE      ACT     ADBE\r\n    [1,]      2012-01-03  2.12505  0.88718  0.29744  0.47946   1.0556\r\n    [2,]      2012-01-04  0.82264 -0.38476 -0.95495 -0.52919 -1.02024\r\n    [3,]      2012-01-05 -0.44787 -0.23157  0.28445  2.74752  0.70472\r\n    [4,]      2012-01-06 -0.51253 -0.93168  0.23891  1.94894  0.83917\r\n    [5,]      2012-01-09  0.58732      0.0  0.46128  0.28436 -0.66376\r\n    [6,]      2012-01-10  0.52193  0.46693  1.31261  1.85986  2.32125\r\n    [7,]      2012-01-11 -0.63413 -0.38895 -1.52066 -3.06604  0.41012\r\n    [8,]      2012-01-12  0.60934 -0.46875  0.50453 -0.93039 -0.30743\r\n    [9,]      2012-01-13 -0.80912  0.50771 -0.47478  0.25752 -0.89348\r\n    [10,]     2012-01-17  0.74711  0.50515    0.297 -7.04176  1.30317\r\n    [11,]     2012-01-18  0.98754  -0.6611  0.17778 -0.06901  1.82314\r\n    [12,]     2012-01-19  0.85617  0.15595   1.1918  3.92605  1.16416\r\n    [13,]     2012-01-20 -0.17065  0.58264  2.42751 -3.58146  0.85611\r\n    [14,]     2012-01-23 -0.04881 -0.07749 -1.20639 -1.61252 -0.88919\r\n    [15,]     2012-01-24  0.37766  0.46404 -0.98738 -2.33432  2.35382\r\n    [16,]     2012-01-25  0.63031 -1.35951  0.81384  3.03107  1.25222\r\n    [17,]     2012-01-26  1.26075  -0.6277  -0.5952  1.78914 -0.51184\r\n    [18,]     2012-01-27 -0.13134   0.2751  -2.5512  1.84142 -0.41781\r\n    [19,]     2012-01-30 -0.14347 -1.02565 -0.68945  0.26747 -0.16116\r\n    [20,]     2012-01-31 -0.72046 -0.59654  0.89834   -2.143 -0.16142\r\n      :\r\n    [314,]    2013-04-04  0.13388  0.88398  1.18103  0.59652  1.16029\r\n    [315,]    2013-04-05 -0.03823 -0.91173 -0.09035  1.39877 -1.89525\r\n    [316,]    2013-04-08 -0.02868   0.6639  1.19062  1.19664   0.9407\r\n    [317,]    2013-04-09  0.19108  0.27533  0.54563 -0.66303  0.86403\r\n    [318,]    2013-04-10  1.62836  1.20253  0.44321 -0.51303  1.19277\r\n    [319,]    2013-04-11  0.51515  0.83864  1.06671  0.56419  1.13448\r\n    [320,]    2013-04-12 -0.52454 -0.37787  0.08747 -0.44082 -0.39894\r\n    [321,]    2013-04-15 -1.80048  -2.7414 -3.52592 -1.34466 -0.95951\r\n    [322,]    2013-04-16  0.37223  0.74762   1.1929   0.9741  1.51316\r\n    [323,]    2013-04-17 -0.63074  2.39859 -1.07975  0.78069 -0.84276\r\n    [324,]    2013-04-18 -0.48049 -1.08314 -0.63528  -1.0802 -0.98479\r\n    [325,]    2013-04-19  0.69118  0.86745  0.77089  1.84469   0.6278\r\n    [326,]    2013-04-22  0.08606 -0.84023  0.27067 -0.64178 -0.47048\r\n    [327,]    2013-04-23  1.48952  0.86721   0.8188  0.93582  0.76063\r\n    [328,]    2013-04-24    0.451  -1.8794 -0.51518 -0.49734 -0.44673\r\n    [329,]    2013-04-25 -2.81414 -0.08252 -0.04492  0.61876  0.84708\r\n    [330,]    2013-04-26 -1.04683 -0.08259 -0.63106  2.05182 -0.31125\r\n    [331,]    2013-04-29  0.03897  0.74085 -0.02261  4.49427  0.33344\r\n    [332,]    2013-04-30  0.84381  0.51807  0.24845  0.14197  0.04438\r\n    [333,]    2013-05-01 -0.14498 -0.08162 -0.94057 -1.27548 -0.82415\r\n\r\nThis will additionally show the names of the fields of any object, and\r\nalso explicitly display the time period of the data.\r\n\r\nTo save an object to disk, simply call function `writeTimedata`, which\r\ninternally uses `writetable` from the `DataFrame` package. In\r\naccordance with `writetable`, the first argument is the filename as\r\nstring, while the second argument is the variable to be saved.\r\n\r\n    writeTimedata(\"data/logRet2.csv\", tm)\r\n\r\n# Functions and operators inherited from DataFrames\r\n\r\nMost of the standard functions and mathematical operators that are\r\ndefined for `DataFrames` are also implemented for `TimeData` types and\r\nshould behave as expected. Whenever possible, functions apply\r\nelementwise to observations only, and you should get back the same\r\ntype that you did use to call the function. In case that this is not\r\npossible, the type that you get back should be the natural first\r\nchoice. For example, elementwise comparisons should return a logical\r\nvalue for each entry, which by definition could not be of type\r\n`Timenum` where only numeric values are allowed. \r\n\r\n    typeof(tm + tm)\r\n    typeof(tm .> 0.5)\r\n\r\n    Timematr (constructor with 9 methods)\r\n    Timedata (constructor with 9 methods)\r\n\r\nThe standard library for `TimeData` comprises all standard operators\r\nand mathematical functions. As expected, these functions all apply\r\nelementwise, and leave the time information untouched. Where\r\nadditional arguments are allowed for `DataFrames`, they are allowed\r\nfor `TimeData` types as well.\r\n\r\n    tm[1:3, 1:3] .> 0.5\r\n    exp(tm[1:3, 1:3])\r\n    round(tm[1:3, 1:3], 2)\r\n\r\n    \r\n    type: Timedata\r\n    dimensions: (3,3)\r\n    3x4 DataFrame:\r\n                 dates     A     B     C\r\n    [1,]    2013-07-01 false false false\r\n    [2,]    2013-07-02  true  true  true\r\n    [3,]    2013-07-03  true false  true\r\n    \r\n    type: Timematr\r\n    dimensions: (3,3)\r\n    3x4 DataFrame:\r\n                 dates       A       B       C\r\n    [1,]    2013-07-01 1.59726   1.547 1.45007\r\n    [2,]    2013-07-02 2.09634 2.42551 2.20417\r\n    [3,]    2013-07-03 1.84294 1.50174 2.25843\r\n    \r\n    type: Timematr\r\n    dimensions: (3,3)\r\n    3x4 DataFrame:\r\n                 dates    A    B    C\r\n    [1,]    2013-07-01 0.47 0.44 0.37\r\n    [2,]    2013-07-02 0.74 0.89 0.79\r\n    [3,]    2013-07-03 0.61 0.41 0.81\r\n\r\nA most likely not exhaustive list of basic functions is\r\n\r\n    TimeDataFunctions = [:(+), :(.+), :(-), :(.-), :(*), :(.*), :(/),\r\n                         :(./), :(.^),\r\n                         :(div), :(mod), :(fld), :(rem),\r\n                         :abs, :sign, :acos, :acosh, :asin, :asinh, :atan,\r\n                         :atanh, :sin, :sinh, :cos, :cosh, :tan, :tanh,\r\n                         :exp, :exp2, :expm1, :log, :log10, :log1p, :log2,\r\n                         :exponent, :sqrt, :gamma, :lgamma, :digamma,\r\n                         :erf, :erfc,\r\n                         :(.==), :(.!=), :(.>), :(.>=), :(.<), :(.<=),\r\n                         :(&), :(|), :($),\r\n                         :round, :ceil, :floor, :trunc]\r\n\r\n# Additional functions\r\n\r\nBeside basic mathematical functions and operators, there are some\r\nadditional basic functions that are defined for each `TimeData` type.\r\nFor example, you can retrieve individual components of your variable\r\nwith the following functions:\r\n\r\n-   **idx:** returns time information as `Array`\r\n\r\n-   **names:** returns variable names as\r\n                  `Array{Union(UTF8String,ASCIIString),1}`\r\n\r\n-   **core:** implemented for subtypes of `AbstractTimematr`, it returns a\r\n    matrix of numeric values\r\n\r\nThese functions shall help to inhibit direct access of `TimeData`\r\nfields, which should be avoided.\r\n\r\nSome further implemented functions are: \r\n\r\n-   `isequal`\r\n\r\n-   `size`\r\n\r\n-   `isna`\r\n\r\nFurthermore, subtypes of type `AbstractTimematr` should already\r\nprovide functionality for basic statistical functions like `mean`,\r\n`var` and `cov`.\r\n\r\n# Acknowledgement\r\n\r\nOf course, any package can only be as good as the individual parts\r\nthat it builds on. Accordingly, I'd like to thank all people that\r\nwere involved in the development of all the functions that were made\r\nready to use for me to build this package upon. In particular, I want\r\nto thank the developers of\r\n\r\n-   the **Julia language**, for their continuous and tremendous efforts\r\n    during the creation of this free, fast and highly flexible\r\n    programming language!\r\n\r\n-   the **DataFrames** package, which definitely provides the best\r\n    representation for general types of data in data analysis. It's a\r\n    role model that every last bit of code of `TimeData` depends on, and\r\n    the interface that every statistics package should use.\r\n\r\n-   the **Datetime** package, which is a thoughtful implementation of\r\n    dates, time and durations, and the backbone of all time components\r\n    in `TimeData`.\r\n\r\n-   the **TimeSeries** package, which follows a different approach to\r\n    handling time series data by storing time information as a column of\r\n    a DataFrame. Having a quite similar goal in mind, the package was a\r\n    great inspiration for me, and occasionally I even could borrow parts\r\n    of code from it (for example, function `readTimedata`).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}