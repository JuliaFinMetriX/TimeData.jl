<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>TimeData documentation</title>
<!-- 2014-07-09 Wed 19:41 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Christian Groll" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<meta charset='utf-8'>
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
<link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
<link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">TimeData documentation</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. TimeData types</a></li>
<li><a href="#sec-2">2. Constructors</a></li>
<li><a href="#sec-3">3. Indexing</a></li>
<li><a href="#sec-4">4. Read, write, io</a></li>
<li><a href="#sec-5">5. Functions and operators inherited from DataFrames</a></li>
<li><a href="#sec-6">6. Additional functions</a></li>
<li><a href="#sec-7">7. Acknowledgement</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> TimeData types</h2>
<div class="outline-text-2" id="text-1">
<p>
All types introduced are subtypes of abstract type <code>AbstractTimedata</code>
and have two fields, separating time information from observations:
</p>
<ul class="org-ul">
<li><b>vals:</b> a <code>DataFrame</code> 
</li>
<li><b>idx:</b> an <code>Array{T, 1}</code>, consisting of either type
<ul class="org-ul">
<li><code>Integer</code>,
</li>
<li><code>Date</code>, or
</li>
<li><code>DateTime</code> (from package <code>Datetime</code>)
</li>
</ul>
</li>
</ul>

<p>
However, accessing these fields directly is considered poor style, as
one could circumvent any constraints on the individual fields this
way! Hence, only reference the fields directly if you really know what
you are doing.
</p>

<p>
Given these commonalities of all <code>TimeData</code> types, there exist several
distinct types that implement different constraints on the
observations. Sorted from most general to most specific case, the
following types are introduced:
</p>
<ul class="org-ul">
<li><b>Timedata:</b> no further restrictions on observations
</li>
<li><b>Timenum:</b> observations may consist of numeric values or missing
values only
</li>
<li><b>Timematr:</b> observations must be numeric values only
</li>
<li><b>Timecop:</b> observations must be numeric values between 0 and 1
only
</li>
</ul>

<p>
Given that these constraints are fulfilled, one is able to define and
use more specific functions matching the data characteristics more
closely. For example, <code>Timematr</code> instances can directly make use of
fast and numerically optimized methods using <code>Array{Float64, 2}</code> under
the hood. Hence, it is important that these constraints are reliably
fulfilled. They are guaranteed as they are hard-coded into variables
at creation through the individual constructors. And, by now, no
further <code>setindex</code> methods exist that would allow data manipulation.
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Constructors</h2>
<div class="outline-text-2" id="text-2">
<p>
For each type, variables can be created by directly handing over
observations as <code>DataFrame</code> and time information as <code>Array</code> to the
inner constructor.
</p>
<div class="org-src-container">

<pre class="src src-julia"><span style="color: #ff0000;">using</span> TimeData
<span style="color: #ff0000;">using</span> Datetime
</pre>
</div>

<div class="org-src-container">

<pre class="src src-julia">vals = <span style="color: #00ffff;">rand</span>(30, 4)
dats = Date{ISOCalendar}[<span style="color: #00ffff;">date</span>(2013, 7, ii) <span style="color: #ff0000;">for</span> ii=1:30]
nams = [:A, :B, :C, :D]
valsDf = <span style="color: #00ffff;">composeDataFrame</span>(vals, nams)

tm = <span style="color: #00ffff;">Timematr</span>(valsDf, dats)
</pre>
</div>

<p>
Besides, there also exist several outer constructors for each type,
allowing more convenient creation. In particular, if observations do
not entail any <code>NAs</code>, there is no need to wrap them up into
<code>DataFrames</code> previously, but <code>TimeData</code> objects can simply be created
from <code>Arrays</code>. Also, there might be situations where variable names
and / or dates are missing. For these cases, there exist more
convenient outer constructors, too, which generally follow the
convention that dates do never precede variable names as arguments.
</p>

<div class="org-src-container">

<pre class="src src-julia">tm = <span style="color: #00ffff;">Timematr</span>(vals, nams, dats)
tm = <span style="color: #00ffff;">Timematr</span>(vals, nams)
tm = <span style="color: #00ffff;">Timematr</span>(vals, dats)
tm = <span style="color: #00ffff;">Timematr</span>(vals)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Indexing</h2>
<div class="outline-text-2" id="text-3">
<p>
The idea of <code>getindex</code> is to stick with the behavior of <code>DataFrames</code>
as far as possible for the basics, while extending it to allow
indexing of rows by dates. Hence, indexing <code>TimeData</code> types should
hopefully fit seamlessly into behavior familiar from other important
types, with only intuitive extensions. However, it is important to
note that indexing deviates from <code>DataFrame</code> behavior in one aspect:
<code>getindex</code> will NEVER change the type of the variable! If you call it
on a <code>Timematr</code> variable, it will also return a <code>Timematr</code> variable,
and if you call it on type <code>Timenum</code> it will return <code>Timenum</code> as well.
Although this seems to be quite logically, this behavior does deviate
from <code>DataFrame</code> behavior in such that, for example, <code>DataFrames</code>
return <code>DataArray</code> for single columns.
</p>

<div class="org-src-container">

<pre class="src src-julia"><span style="color: #00ffff;">typeof</span>(valsDf[:, 1])
<span style="color: #00ffff;">typeof</span>(tm[:, 1])

<span style="color: #00ffff;">typeof</span>(valsDf[1, 1])
<span style="color: #00ffff;">typeof</span>(tm[1, 1])

<span style="color: #00ffff;">## </span><span style="color: #00ffff;">empty instance</span>
<span style="color: #00ffff;">typeof</span>(tm[4:3, 5:4])
</pre>
</div>

<p>
This will print:
</p>
<pre class="example">
DataArray{Float64,1} (constructor with 1 method)
Timematr{Date{ISOCalendar}} (constructor with 1 method)

Float64
Timematr{Date{ISOCalendar}} (constructor with 1 method)


Timematr{Date{ISOCalendar}} (constructor with 1 method)
</pre>


<p>
Possible ways of indexing are:
</p>
<div class="org-src-container">

<pre class="src src-julia"><span style="color: #00ffff;">## </span><span style="color: #00ffff;">indexing by numeric indices</span>
tmp = tm[2:4]
tmp = tm[3:5, 1:2]
tmp = tm[5, :]
tmp = tm[2]
tmp = tm[5:8, 2]
tmp = tm[5, 3]

<span style="color: #00ffff;">## </span><span style="color: #00ffff;">indexing with column names as symbols</span>
tmp = tm[:A]
tmp = tm[5, [:A, :B]]

<span style="color: #00ffff;">## </span><span style="color: #00ffff;">logical indexing</span>
logicCol = [<span style="color: #ff00ff;">true</span>, <span style="color: #ff00ff;">false</span>, <span style="color: #ff00ff;">true</span>, <span style="color: #ff00ff;">false</span>]
logicRow = <span style="color: #00ffff;">repmat</span>([<span style="color: #ff00ff;">true</span>, <span style="color: #ff00ff;">false</span>, <span style="color: #ff00ff;">true</span>], 10, 1)[:]
tmp = tm[logicCol]
tmp = tm[logicRow, logicCol]
tmp = tm[logicRow, :]

<span style="color: #00ffff;">## </span><span style="color: #00ffff;">logically indexing rows directly from expression</span>
ex = :(A .&gt; 0.5)
tmp = tm[ex, :]

<span style="color: #00ffff;">## </span><span style="color: #00ffff;">indexing by date</span>
tmp = tm[<span style="color: #00ffff;">date</span>(2013, 07, 04)]

datesToFind = Date{ISOCalendar}[<span style="color: #00ffff;">date</span>(2013, 07, ii) <span style="color: #ff0000;">for</span> ii=12:18]
tmp = tm[datesToFind]
tm[<span style="color: #00ffff;">date</span>(2013,07,03):<span style="color: #00ffff;">date</span>(2013,07,12)]
tm[<span style="color: #00ffff;">date</span>(2013,07,03):<span style="color: #00ffff;">date</span>(2013,07,12), :D]
tm[<span style="color: #00ffff;">date</span>(2013,07,03):<span style="color: #00ffff;">date</span>(2013,07,12),
             [<span style="color: #ff00ff;">true</span>, <span style="color: #ff00ff;">false</span>, <span style="color: #ff00ff;">false</span>, <span style="color: #ff00ff;">true</span>]]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Read, write, io</h2>
<div class="outline-text-2" id="text-4">
<p>
Data can easily be imported from csv-files using function
<code>readTimedata</code>. Under the hood, the function makes use of <code>readtable</code>
from the <code>DataFrames</code> package. Additionally, columns are parsed for
dates similar to function <code>readtime</code> from package <code>TimeSeries</code>. The
first column matching the regexp for dates will be chosen as time
identifier. 
</p>
<div class="org-src-container">

<pre class="src src-julia">tm = <span style="color: #00ffff;">readTimedata</span>(<span style="color: #00ff00;">"data/logRet.csv"</span>)
</pre>
</div>

<p>
After loading the data, Julia will call the standard <code>display</code> method
to show information about the data:
</p>

<pre class="example">
type: Timematr{Date{ISOCalendar}}
dimensions: (333,348)
333x6 DataFrame:
               dates      MMM      ABT      ACE      ACT     ADBE
[1,]      2012-01-03  2.12505  0.88718  0.29744  0.47946   1.0556
[2,]      2012-01-04  0.82264 -0.38476 -0.95495 -0.52919 -1.02024
[3,]      2012-01-05 -0.44787 -0.23157  0.28445  2.74752  0.70472
[4,]      2012-01-06 -0.51253 -0.93168  0.23891  1.94894  0.83917
[5,]      2012-01-09  0.58732      0.0  0.46128  0.28436 -0.66376
[6,]      2012-01-10  0.52193  0.46693  1.31261  1.85986  2.32125
[7,]      2012-01-11 -0.63413 -0.38895 -1.52066 -3.06604  0.41012
[8,]      2012-01-12  0.60934 -0.46875  0.50453 -0.93039 -0.30743
[9,]      2012-01-13 -0.80912  0.50771 -0.47478  0.25752 -0.89348
[10,]     2012-01-17  0.74711  0.50515    0.297 -7.04176  1.30317
[11,]     2012-01-18  0.98754  -0.6611  0.17778 -0.06901  1.82314
[12,]     2012-01-19  0.85617  0.15595   1.1918  3.92605  1.16416
[13,]     2012-01-20 -0.17065  0.58264  2.42751 -3.58146  0.85611
[14,]     2012-01-23 -0.04881 -0.07749 -1.20639 -1.61252 -0.88919
[15,]     2012-01-24  0.37766  0.46404 -0.98738 -2.33432  2.35382
[16,]     2012-01-25  0.63031 -1.35951  0.81384  3.03107  1.25222
[17,]     2012-01-26  1.26075  -0.6277  -0.5952  1.78914 -0.51184
[18,]     2012-01-27 -0.13134   0.2751  -2.5512  1.84142 -0.41781
[19,]     2012-01-30 -0.14347 -1.02565 -0.68945  0.26747 -0.16116
[20,]     2012-01-31 -0.72046 -0.59654  0.89834   -2.143 -0.16142
  :
[314,]    2013-04-04  0.13388  0.88398  1.18103  0.59652  1.16029
[315,]    2013-04-05 -0.03823 -0.91173 -0.09035  1.39877 -1.89525
[316,]    2013-04-08 -0.02868   0.6639  1.19062  1.19664   0.9407
[317,]    2013-04-09  0.19108  0.27533  0.54563 -0.66303  0.86403
[318,]    2013-04-10  1.62836  1.20253  0.44321 -0.51303  1.19277
[319,]    2013-04-11  0.51515  0.83864  1.06671  0.56419  1.13448
[320,]    2013-04-12 -0.52454 -0.37787  0.08747 -0.44082 -0.39894
[321,]    2013-04-15 -1.80048  -2.7414 -3.52592 -1.34466 -0.95951
[322,]    2013-04-16  0.37223  0.74762   1.1929   0.9741  1.51316
[323,]    2013-04-17 -0.63074  2.39859 -1.07975  0.78069 -0.84276
[324,]    2013-04-18 -0.48049 -1.08314 -0.63528  -1.0802 -0.98479
[325,]    2013-04-19  0.69118  0.86745  0.77089  1.84469   0.6278
[326,]    2013-04-22  0.08606 -0.84023  0.27067 -0.64178 -0.47048
[327,]    2013-04-23  1.48952  0.86721   0.8188  0.93582  0.76063
[328,]    2013-04-24    0.451  -1.8794 -0.51518 -0.49734 -0.44673
[329,]    2013-04-25 -2.81414 -0.08252 -0.04492  0.61876  0.84708
[330,]    2013-04-26 -1.04683 -0.08259 -0.63106  2.05182 -0.31125
[331,]    2013-04-29  0.03897  0.74085 -0.02261  4.49427  0.33344
[332,]    2013-04-30  0.84381  0.51807  0.24845  0.14197  0.04438
[333,]    2013-05-01 -0.14498 -0.08162 -0.94057 -1.27548 -0.82415
</pre>

<p>
As one can see, the <code>display</code> method will show the type of the
variable, together with its dimensions and a snippet into the first
values. Note that the number of columns does not entail the dates
column, but does only count the columns of the remaining variables.
Inherently, <code>display</code> makes use of the method that is implemented for
<code>DataFrames</code>, which is the reason for the somewhat misleading output
line <code>333x6 DataFrame:</code>. An issue that still remains to be fixed. In
contrast to the standard output of <code>DataFrames</code>, there is no explicit
information for the rest of the columns. 
</p>

<p>
An even more elaborate way of looking at the data contained in a
<code>TimeData</code> type is function <code>str</code> (following the name used in R),
which will print:
</p>

<div class="org-src-container">

<pre class="src src-julia"><span style="color: #00ffff;">str</span>(tm)
</pre>
</div>

<pre class="example">
type: Timematr{Date{ISOCalendar}}
:vals  		  DataFrame
:idx  		  Array{Date{ISOCalendar},1}

dimensions: (333,348)

-------------------------------------------
From: 2012-01-03, To: 2013-05-01
-------------------------------------------

333x6 DataFrame:
               dates      MMM      ABT      ACE      ACT     ADBE
[1,]      2012-01-03  2.12505  0.88718  0.29744  0.47946   1.0556
[2,]      2012-01-04  0.82264 -0.38476 -0.95495 -0.52919 -1.02024
[3,]      2012-01-05 -0.44787 -0.23157  0.28445  2.74752  0.70472
[4,]      2012-01-06 -0.51253 -0.93168  0.23891  1.94894  0.83917
[5,]      2012-01-09  0.58732      0.0  0.46128  0.28436 -0.66376
[6,]      2012-01-10  0.52193  0.46693  1.31261  1.85986  2.32125
[7,]      2012-01-11 -0.63413 -0.38895 -1.52066 -3.06604  0.41012
[8,]      2012-01-12  0.60934 -0.46875  0.50453 -0.93039 -0.30743
[9,]      2012-01-13 -0.80912  0.50771 -0.47478  0.25752 -0.89348
[10,]     2012-01-17  0.74711  0.50515    0.297 -7.04176  1.30317
[11,]     2012-01-18  0.98754  -0.6611  0.17778 -0.06901  1.82314
[12,]     2012-01-19  0.85617  0.15595   1.1918  3.92605  1.16416
[13,]     2012-01-20 -0.17065  0.58264  2.42751 -3.58146  0.85611
[14,]     2012-01-23 -0.04881 -0.07749 -1.20639 -1.61252 -0.88919
[15,]     2012-01-24  0.37766  0.46404 -0.98738 -2.33432  2.35382
[16,]     2012-01-25  0.63031 -1.35951  0.81384  3.03107  1.25222
[17,]     2012-01-26  1.26075  -0.6277  -0.5952  1.78914 -0.51184
[18,]     2012-01-27 -0.13134   0.2751  -2.5512  1.84142 -0.41781
[19,]     2012-01-30 -0.14347 -1.02565 -0.68945  0.26747 -0.16116
[20,]     2012-01-31 -0.72046 -0.59654  0.89834   -2.143 -0.16142
  :
[314,]    2013-04-04  0.13388  0.88398  1.18103  0.59652  1.16029
[315,]    2013-04-05 -0.03823 -0.91173 -0.09035  1.39877 -1.89525
[316,]    2013-04-08 -0.02868   0.6639  1.19062  1.19664   0.9407
[317,]    2013-04-09  0.19108  0.27533  0.54563 -0.66303  0.86403
[318,]    2013-04-10  1.62836  1.20253  0.44321 -0.51303  1.19277
[319,]    2013-04-11  0.51515  0.83864  1.06671  0.56419  1.13448
[320,]    2013-04-12 -0.52454 -0.37787  0.08747 -0.44082 -0.39894
[321,]    2013-04-15 -1.80048  -2.7414 -3.52592 -1.34466 -0.95951
[322,]    2013-04-16  0.37223  0.74762   1.1929   0.9741  1.51316
[323,]    2013-04-17 -0.63074  2.39859 -1.07975  0.78069 -0.84276
[324,]    2013-04-18 -0.48049 -1.08314 -0.63528  -1.0802 -0.98479
[325,]    2013-04-19  0.69118  0.86745  0.77089  1.84469   0.6278
[326,]    2013-04-22  0.08606 -0.84023  0.27067 -0.64178 -0.47048
[327,]    2013-04-23  1.48952  0.86721   0.8188  0.93582  0.76063
[328,]    2013-04-24    0.451  -1.8794 -0.51518 -0.49734 -0.44673
[329,]    2013-04-25 -2.81414 -0.08252 -0.04492  0.61876  0.84708
[330,]    2013-04-26 -1.04683 -0.08259 -0.63106  2.05182 -0.31125
[331,]    2013-04-29  0.03897  0.74085 -0.02261  4.49427  0.33344
[332,]    2013-04-30  0.84381  0.51807  0.24845  0.14197  0.04438
[333,]    2013-05-01 -0.14498 -0.08162 -0.94057 -1.27548 -0.82415
</pre>

<p>
This will additionally show the names of the fields of any object, and
also explicitly display the time period of the data.
</p>

<p>
To save an object to disk, simply call function <code>writeTimedata</code>, which
internally uses <code>writetable</code> from the <code>DataFrame</code> package. In
accordance with <code>writetable</code>, the first argument is the filename as
string, while the second argument is the variable to be saved.
</p>

<div class="org-src-container">

<pre class="src src-julia"><span style="color: #00ffff;">writeTimedata</span>(<span style="color: #00ff00;">"data/logRet2.csv"</span>, tm)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Functions and operators inherited from DataFrames</h2>
<div class="outline-text-2" id="text-5">
<p>
Most of the standard functions and mathematical operators that are
defined for <code>DataFrames</code> are also implemented for <code>TimeData</code> types and
should behave as expected. Whenever possible, functions apply
elementwise to observations only, and you should get back the same
type that you did use to call the function. In case that this is not
possible, the type that you get back should be the natural first
choice. For example, elementwise comparisons should return a logical
value for each entry, which by definition could not be of type
<code>Timenum</code> where only numeric values are allowed. 
</p>

<div class="org-src-container">

<pre class="src src-julia"><span style="color: #00ffff;">typeof</span>(tm + tm)
<span style="color: #00ffff;">typeof</span>(tm .&gt; 0.5)
</pre>
</div>

<pre class="example">
Timematr (constructor with 9 methods)
Timedata (constructor with 9 methods)
</pre>

<p>
The standard library for <code>TimeData</code> comprises all standard operators
and mathematical functions. As expected, these functions all apply
elementwise, and leave the time information untouched. Where
additional arguments are allowed for <code>DataFrames</code>, they are allowed
for <code>TimeData</code> types as well.
</p>

<div class="org-src-container">

<pre class="src src-julia">tm[1:3, 1:3] .&gt; 0.5
<span style="color: #00ffff;">exp</span>(tm[1:3, 1:3])
<span style="color: #00ffff;">round</span>(tm[1:3, 1:3], 2)
</pre>
</div>

<pre class="example">
type: Timedata
dimensions: (3,3)
3x4 DataFrame:
             dates     A     B     C
[1,]    2013-07-01 false false false
[2,]    2013-07-02  true  true  true
[3,]    2013-07-03  true false  true

type: Timematr
dimensions: (3,3)
3x4 DataFrame:
             dates       A       B       C
[1,]    2013-07-01 1.59726   1.547 1.45007
[2,]    2013-07-02 2.09634 2.42551 2.20417
[3,]    2013-07-03 1.84294 1.50174 2.25843

type: Timematr
dimensions: (3,3)
3x4 DataFrame:
             dates    A    B    C
[1,]    2013-07-01 0.47 0.44 0.37
[2,]    2013-07-02 0.74 0.89 0.79
[3,]    2013-07-03 0.61 0.41 0.81
</pre>

<p>
A most likely not exhaustive list of basic functions is
</p>
<div class="org-src-container">

<pre class="src src-julia">TimeDataFunctions = [:(+), :(.+), :(-), :(.-), :(*), :(.*), :(/),
                     :(./), :(.^),
                     :(div), :(mod), :(fld), :(rem),
                     :abs, :sign, :acos, :acosh, :asin, :asinh, :atan,
                     :atanh, :sin, :sinh, :cos, :cosh, :tan, :tanh,
                     :exp, :exp2, :expm1, :log, :log10, :log1p, :log2,
                     :exponent, :sqrt, :gamma, :lgamma, :digamma,
                     :erf, :erfc,
                     :(.==), :(.!=), :(.&gt;), :(.&gt;=), :(.&lt;), :(.&lt;=),
                     :(&amp;), :(|), :($),
                     :round, :ceil, :floor, :trunc]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Additional functions</h2>
<div class="outline-text-2" id="text-6">
<p>
Beside basic mathematical functions and operators, there are some
additional basic functions that are defined for each <code>TimeData</code> type.
For example, you can retrieve individual components of your variable
with the following functions:
</p>
<ul class="org-ul">
<li><b>idx:</b> returns time information as <code>Array</code>
</li>
<li><b>names:</b> returns variable names as
              <code>Array{Union(UTF8String,ASCIIString),1}</code> 
</li>
<li><b>core:</b> implemented for subtypes of <code>AbstractTimematr</code>, it returns a
matrix of numeric values
</li>
</ul>
<p>
These functions shall help to inhibit direct access of <code>TimeData</code>
fields, which should be avoided.
</p>

<p>
Some further implemented functions are: 
</p>
<ul class="org-ul">
<li><code>isequal</code> 
</li>
<li><code>size</code>
</li>
<li><code>isna</code>
</li>
</ul>

<p>
Furthermore, subtypes of type <code>AbstractTimematr</code> should already
provide functionality for basic statistical functions like <code>mean</code>,
<code>var</code> and <code>cov</code>.
</p>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Acknowledgement</h2>
<div class="outline-text-2" id="text-7">
<p>
Of course, any package can only be as good as the individual parts
that it builds on. Accordingly, I'd like to thank all people that
were involved in the development of all the functions that were made
ready to use for me to build this package upon. In particular, I want
to thank the developers of
</p>
<ul class="org-ul">
<li>the <b>Julia language</b>, for their continuous and tremendous efforts
during the creation of this free, fast and highly flexible
programming language!
</li>
<li>the <b>DataFrames</b> package, which definitely provides the best
representation for general types of data in data analysis. It's a
role model that every last bit of code of <code>TimeData</code> depends on, and
the interface that every statistics package should use.
</li>
<li>the <b>Datetime</b> package, which is a thoughtful implementation of
dates, time and durations, and the backbone of all time components
in <code>TimeData</code>.
</li>
<li>the <b>TimeSeries</b> package, which follows a different approach to
handling time series data by storing time information as a column of
a DataFrame. Having a quite similar goal in mind, the package was a
great inspiration for me, and occasionally I even could borrow parts
of code from it (for example, function <code>readTimedata</code>).
</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Christian Groll</p>
<p class="date">Created: 2014-07-09 Wed 19:41</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 23.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.1)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
