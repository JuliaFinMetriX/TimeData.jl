#+OPTIONS: eval:never-export
#+PROPERTY: exports both
#+PROPERTY: results output
#+PROPERTY: session *julia-readme*

[[https://travis-ci.org/cgroll/TimeData.jl][https://travis-ci.org/cgroll/TimeData.jl.png]]
[[https://coveralls.io/r/cgroll/TimeData.jl?branch=master][https://coveralls.io/repos/cgroll/TimeData.jl/badge.png?branch=master]]

* What? Why

The goal of the package TimeData is to provide *fast*, *robust* and
*convenient* representation of time series data. This shall be
achieved through introduction of several new composite types, matching
the characteristics of various types of time series data more closely.

* Behavior

Behavior of ~TimeData~ types in most cases borrows heavily from
~DataFrames~, as this package provides an excellent way of
representing quite general data. In particular, ~DataFrames~ already
allow for named columns, as well as missing observations. In many
situations, however, the time information of the data adds a separate
and unique dimension to the data. The different characteristics of
time data and observations then would not be accounted for
sufficiently, if time was only one further column amongst the other
observations.

The ~TimeData~ package provides users with the well-known experience
of ~DataFrames~ whenever possible. It only deviates where additional
convenience can be achieved through a more explicit separation between
time information and observations. In particular, the following
features allow convenient data handling.

** Intuitive indexing

Extending the fabulous ways of indexing already provided by
~DataFrames~, data can easily be accessed - amongst others - through
variable names and dates.

#+BEGIN_SRC julia :results silent
   using TimeData
   using Datetime
   tm = TimeData.readTimedata("data/logRet.csv")
#+END_SRC

Using a range of dates:
#+BEGIN_SRC julia
   tm[date(2012, 01, 19):date(2012, 01, 23), 1:2]
#+END_SRC

#+RESULTS:
: 
: type: Timematr
: dimensions: (3,2)
: 3x3 DataFrame:
:              dates      MMM      ABT
: [1,]    2012-01-19  0.85617  0.15595
: [2,]    2012-01-20 -0.17065  0.58264
: [3,]    2012-01-23 -0.04881 -0.07749

Using numeric indexing:
#+BEGIN_SRC julia
   tm[3:8, 1:3]
#+END_SRC

#+RESULTS:
#+begin_example

type: Timematr
dimensions: (6,3)
6x4 DataFrame:
             dates      MMM      ABT      ACE
[1,]    2012-01-05 -0.44787 -0.23157  0.28445
[2,]    2012-01-06 -0.51253 -0.93168  0.23891
[3,]    2012-01-09  0.58732      0.0  0.46128
[4,]    2012-01-10  0.52193  0.46693  1.31261
[5,]    2012-01-11 -0.63413 -0.38895 -1.52066
[6,]    2012-01-12  0.60934 -0.46875  0.50453
#+end_example

Using column names:
#+BEGIN_SRC julia
   tm[3:8, [:ABT, :MMM]]
#+END_SRC

#+RESULTS:
#+begin_example

type: Timematr
dimensions: (6,2)
6x3 DataFrame:
             dates      ABT      MMM
[1,]    2012-01-05 -0.23157 -0.44787
[2,]    2012-01-06 -0.93168 -0.51253
[3,]    2012-01-09      0.0  0.58732
[4,]    2012-01-10  0.46693  0.52193
[5,]    2012-01-11 -0.38895 -0.63413
[6,]    2012-01-12 -0.46875  0.60934
#+end_example


** Separate time information

Through the built-in separation of time information and observations,
functions that do not naturally extend to time data can simply be
overloaded and delegated to observations only.

Calculating mean values for each column:
#+BEGIN_SRC julia
   mean(tm[:, 1:3], 1)
#+END_SRC

#+RESULTS:
: 1x3 DataFrame:
:               MMM      ABT       ACE
: [1,]    0.0837788 0.106037 0.0806674

Calculating mean values per date:
#+BEGIN_SRC julia
   TimeData.rowmeans(tm[1:5, :])
#+END_SRC

#+RESULTS:
#+begin_example

type: Timematr
dimensions: (5,1)
5x2 DataFrame:
             dates         x1
[1,]    2012-01-03    1.39846
[2,]    2012-01-04 -0.0184982
[3,]    2012-01-05   0.491411
[4,]    2012-01-06  -0.138277
[5,]    2012-01-09    0.39854
#+end_example

** Additional benefits

*** Time index

When linking observations to points in time, there are three different
time indices that can be used with the package:

- ~Array{Date{C<:Calendar}, 1}~
- ~Array{DateTime{C<:Calendar, T<:Offsets},1}~
- ~Array{Integer, 1}~

*** Specialized types
The package introduces several new types for time series data. All
types treat time information consistently, internally stored in a
separate field. In addition, each new type tries to match one
particular type of time series data as closely as possible. So far,
the following types exist:
- ~Timedata~ :: observations are stored as ~DataFrame~ without further
                restrictions
- ~Timenum~ :: observations may only consist of numeric values or
               missing values
- ~Timematr~ :: observations must be numeric values only
- ~Timecop~ :: observations must be numeric values between 0 and 1

*** Speed
The package tries to achieve high performance by delegating
functionality to the most specialized case. For example, methods for
instances of ~Timematr~ are delegated to ~Array{Float64, 2}~, as they
are not allowed to entail ~NAs~ anyways. 

*** Robustness
Through the hard-coded distinction between time data and observations,
code will become cleaner and less error-prone, as users can not mess
with time information as easily anymore. Functions that apply to
observations only, do not need to explicitly take into account the
time information anymore. For example, storing dates in the first
column of a ~DataFrame~, simply rescaling observations by a factor of
2 becomes:

#+BEGIN_SRC julia :results silent
newDf = [DataFrame(df[:, 1]) 2*df[:, 2:end]]
#+END_SRC

In contrast, for ~TimeData~ types, the code is 
#+BEGIN_SRC julia :results silent
newTm = 2*tm
#+END_SRC

* Under the hood: implementation

The balancing act between emulating and extending ~DataFrames~ is
implemented in Julia maybe a bit less naturally than in traditional
object oriented programming languages. There, one can easily inherit
behavior from other classes through subclasses, thereby overwriting
inherited methods whenever desired. In Julia, however, composite types
are not allowed to be subtypes of other composite types, but only
abstract types may act as parent. Under the hood, ~TimeData~ types
hence inherit their behavior by owning a field of type ~DataFrame~.
This way, functions can easily be delegated to this field whenever
necessary. For a more elaborate discussion on this topic and the
interior design of ~TimeData~, take a look at [[http://grollchristian.wordpress.com/2014/01/22/julia-inheriting-behavior/][this post]] on my blog. 

Time information in ~TimeData~ is handled through types of the package
~Datetime~. 


* Current state

So far, only type ~Timematr~ has functionality that goes beyond the
basic methods inherited from ~DataFrames~. Still, all ~TimeData~ types
should already provide a convenient way to represent time series data,
and any ~DataFrame~ functionality in principle can easily be regained
by delegating functions to field ~vals~. Also, I only tested
~TimeData~ types with ~date~ type from the ~Datetime~ package myself,
and not yet with type ~datetime~.

* Documentation

For more details, visit the [[http://cgroll.github.io/TimeData.jl][online documentation]].
