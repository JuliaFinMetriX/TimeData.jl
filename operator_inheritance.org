* Operator / function inheritance

Two types of function:
1. returning superclass 
2. returning third type

** Field of superclass

Strategy for 1:
- delegate function to field
- check constraints
- assign returned superclass object to field
#+BEGIN_SRC julia
   function f(pf::Portfolio, x)
       df = f(pf.vals, x)
       return Portfolio(df)
   end
#+END_SRC

Strategy for 2:
- delegate function to field
#+BEGIN_SRC julia
   function f(pf::Portfolio, x)
       return f(pf.vals, x)
   end
#+END_SRC

** Superclass of same structure with less constraints

Strategy for 1:
- convert to superclass
- call function on superclass
- check constraints
- re-convert to subclass
#+BEGIN_SRC julia
   function deleverage(inv::Investment, factor::Float64)
       weights = inv.weights / factor
       return Investment(weights)
   end
   
   function deleverage(pf::Portfolio, factor::Float64)
       inv = convert(Investment, pf)
       inv2 = deleverage!(inv, factor)
       return pf = convert(Portfolio, inv2)
   end
#+END_SRC
Alternatively, one could also simply define the same function for both
types:
#+BEGIN_SRC julia
   function deleverage!(inv::Investment, factor::Float64)
       weights = inv.weights / factor
       return Investment(weights)
   end
   
   function deleverage!(pf::Portfolio, factor::Float64)
       weights = pf.weights / factor
       return Portfolio(weights)
   end
#+END_SRC
This could also be achieved through metaprogramming:
#+BEGIN_SRC julia
   
   function deleverage!(x::$(type), factor::Float64)
       x.weights = x.weights / factor
   end
      
      
#+END_SRC


Strategy for 2:
- convert to superclass
- call function on superclass
- return value
#+BEGIN_SRC julia
   function getPMean(pf::Portfolio, mus)
       inv = convert(Investments, pf)
       tn = getPMean(inv, mus)
       return tn
   end
#+END_SRC
Alternatively, use abstract supertype:
#+BEGIN_SRC julia
   function getPMean(x::AbstractInvestment, mus)
       ## function body
   end
#+END_SRC

* Multiple function arguments

In principle, in order to completely overload a function, one would
have to define the respective detour for all possible function calls:
#+BEGIN_SRC julia
   f(df, x)
   f(df, x, y)
   f(x, df)
   f(x, y, df)
   f(x, y, df, z)
#+END_SRC
Ideally, the detour will be defined for each function only once. This
could sometimes be achieved with args...
#+BEGIN_SRC julia
   function +(pf, args...)
       Portfolio(+(pf.weights, args...))
   end
#+END_SRC

However, this way we will get problems with function ambiguity: 
.==(Any, Array{Float64, 1})
